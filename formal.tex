\chapter{The Rules of Type Theory}
\label{cha:rules}
\bgroup % restrict the scope of our macros to this section

\newcommand{\ctx}{\ \mathsf{ctx}}
\newcommand{\emptyctx}{\ensuremath{\cdot}}

\newcommand{\production}{\vcentcolon\vcentcolon=}

\newcommand{\mkbox}[1]{\ensuremath{#1}}

\newcommand{\app}{\mathsf{app}}

\newcommand{\gothic}{\mathfrak}
\newcommand{\gP}{{\gothic p}}
\newcommand{\gM}{{\gothic M}}
\newcommand{\gN}{{\gothic N}}
\newcommand{\rats}{\mathbb{Q}}
\newcommand{\ints}{\mathbb{Z}}

\newcommand{\lbr}{\lbrack\!\lbrack}
\newcommand{\rbr}{\rbrack\!\rbrack}
\newcommand{\sem}[2] {\lbr #1 \rbr_{#2}}  % interpretation of the terms
\newcommand{\APP}[2] {{\sf app}(#1,#2)}  % interpretation of the terms
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Con}{{\sf Con}}
\newcommand{\Elem}{{\sf Elem}}
\newcommand{\myId}{1}
\newcommand{\mypp}{{\sf p}}
\newcommand{\qq}{{\sf q}}
\newcommand{\mySp}{{\sf Sp}}
\newcommand{\conv}{\sim}
\newcommand{\LIM}{{\sf lim}}
\newcommand{\nn}{{\sf n}}
\newcommand{\Fam}{{\sf Fam}}

\section{Introduction}\label{formal-intro}

A major advantage of type theory is that it 
simultaneously incorporates the rules of mathematics with the rules of logic,
thus providing a completely self-contained system for formulating theorems
and their proofs, and enabling their computer verification.  In this appendix we
offer two presentations of the formal system and its syntax.  The first
presentation (in \autoref{syntax-informally}) is written informally and
emphasizes an underlying untyped type theory as basic support for the syntax
and for aspects of computation in the system.  The second (in
\autoref{syntax-more-formally}) is more formal and hence more self-contained,
and is closer to standard practice in the literature of type theory.

In \autoref{cha:typetheory}, we presented the two basic {\em judgments} of type
theory. The first, $a:A$, asserts that a term $a$ has type $A$.  The second,
$a\jdeq b:A$, states that the two terms $a$ and $b$ are {\em judgmentally equal}
at type $A$. These judgments are inductively defined by a set of {\em inference
rules}, to be presented below; a judgment holds exactly when it can be concluded
by a closed derivation composed of these inference rules.

To give a proof $a$ of a proposition $A$ is to derive $a:A$; in the book, we
usually give informal arguments which describe the construction of $a$, but
formally, one must give a precise term $a$ and a full derivation that $a:A$. It
is possible to algorithmically determine the type, if any, of a term. It is also
possible to algorithmically establish equality between terms; an algorithm is
included in \autoref{syntax-informally}.

However, the main difference between the book's type theory and formal type
theory is that formally, judgments are formulated in an ambient {\em
context}, or list of assumptions, of the form
\[
  \Gamma =  x_1:A_1, x_2:A_2,\dots,x_n:A_n
\]
Here each pair $x_i:A_i$ in the list $\Gamma$ consists of a variable $x_i$ and a
type $A_i$ in which at most the variables $x_1,\dots,x_{i-1}$ occur freely, signifying
that each variable $x_i$ is assumed to have type $A_i$ in the context $\Gamma$. 
(We discuss the importance of the context in more depth in
\autoref{syntax-more-formally}.)

Thus, the typing judgment
\[
  \Gamma \vdash a:A
\]
denotes that $a$ has type $A$ in the context $\Gamma$; in other words, the
variables declared in $\Gamma$ may appear freely in $a$ and $A$. When $\Gamma$
is empty, we may write simply
\[
  \vdash a:A
\]
or
\[
  \emptyctx \vdash a:A
\]
where $\emptyctx$ denotes the empty context. The same applies for the equality
judgment
\[
  \Gamma \vdash a\jdeq b:A
\]

Such judgments are justified only for contexts that are well formed.  We
introduce a third primitive judgment
\[
  \vdash \Gamma \ctx
\]
to express that notion.  Intuitively, this requires that each $A_i$ is a valid
type in the context $x_1:A_1, x_2:A_2,\dots,x_{i-1}:A_{i-1}$.

We write $B[a/x]$ for the substitution of a term $a$ for free occurrences of
the variable $x$ in the term $B$, with possible renaming for avoiding capture
of variables, as discussed in \autoref{sec:function-types}.  We use
$$B[a_1,\dots,a_n/x_1,\dots,x_n]$$ as an abbreviation for the simultaneous
substitution of the expressions $a_1,\dots,a_n$ for the variables
$x_1,\dots,x_n$.

To {\em bind} a variable $x$ to an expression $B$ means to incorporate both of
them into a larger expression or {\em abstraction}, whose purpose is to
annnotate $B$ with information about which variable is available next for
substitution.  Various notations are used for binding, such as $x \mapsto B$,
$\lam x B$, and $x.B$, depending on the situation.  We may write $C[a]$ for the
substitution of a term $a$ for the variable in the abstracted expression, i.e.,
we may define $(x.B)[a]$ to be $B[a/x]$.  As discussed in
\autoref{sec:function-types}, changing the name of a bound variable everywhere
within an expression is considered not to change the expression.

One may also regard each variable $x_i$ of a sentence
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n \vdash a : A
\]
to be bound within the sentence, with its {\em scope} incorporating the
expressions $A_{i+1}$, \dots, $A_n$, $a$, and $A$.

\section{The inference rules, informally}\label{syntax-informally}

\subsection{The Raw Syntax}

The objects and types of our type theory may be written as terms using
the following syntax, which is an extension of $\lambda$-calculus with {\em
  variables} $x, x',\dots$, {\em primitive} constants $c,c',\dots$, {\em
  defined} constants $f,f',\dots$, and term forming operations
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]

The notation used here means that a term $t$ is either a variable $x$, or it
has the form $\lam{x} t$ where $x$ is a variable and $t$ is a term, or it has
the form $t(t')$ where $t$ and $t'$ are terms, or it is a primitive constant
$c$, or it is a defined constant $f$.  The syntactic markers '$\lambda$', '(',
')', and '.' are punctuation for guiding the human eye.

We use $t(t_1,\dots,t_n)$ as an abbreviation for the repeated application
$t(t_1)(t_2)\dots (t_n)$.  We may also use {\em infix} notation, writing $t_1\;
\star\; t_2$ for $\star(t_1,t_2)$ when $\star$ is a primitive or defined
constant.

Each defined constant will have zero, one or more {\em defining equations}.
There will be two kinds of defined constant.  An {\em explicit} defined
constant $f$ will have a single defining equation
  \[ f(x_1,\dots,x_n)\defeq t,\]
where $t$ does not involve $f$.  

As an example, we introduce the explicit defined constant $\circ$, for
composition of functions, with defining equation
  \[ \circ (x,y)(z) \defeq x(y(z)),\]
and we use infix notation $x\circ y$ for $\circ(x,y)$.

The second kind of defined constant will be used in connection with a form of type having some primitive constants that are used to introduce elements into types of that form.  With each such primitive constant $c$ there will be a defining equation of the form
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
where now $f$ may occur in $t$, but now only in such a way that, in the context
where $f$ is introduced it will be a totally defined typed function.  The
paradigm examples of such defined functions are the functions defined by
primitive recursion on the natural numbers.  We may call this kind of
definition of a function a {\em total recursive definition}.  In computer
science and logic this kind of definition of a function on a recursive data
type has been called a {\em definition by structural recursion}.

We introduce the notion of {\em convertibility} $t \conv t'$ between terms $t$
and $t'$ as the equivalence relation generated by all instances of the
elementary reduction
\[
  (\lam{x} t)(u) \conv t[u/x].
\]
and by all instances of defining equations, such as the one for $x \circ y$
presented above, and by those to be introduced below.

The equality judgments $t \jdeq u : A$ are derived by the following single rule.
\begin{itemize}
\item if $t:A$, $u:A$, and $t \conv u$, then $t \jdeq u : A$
\end{itemize}
Equality is an equivalence relation.

%% \begin{itemize}
%% \item if $t:A$, then $t \jdeq t : A$
%% \item if $t \jdeq u : A$, then $u \jdeq t : A$
%% \item if $t \jdeq u : A$ and $u \jdeq v : A$, then $t \jdeq v : A$
%% \end{itemize}

The following conversion rule allows us to replace a type by one equal to it in
a typing judgment.
\begin{itemize}
\item if $a:A$ and $A \jdeq B$ then $a:B$
\end{itemize}

\subsection{Type Universes}

We introduce a hierarchy of {\em universes} denoted by primitive constants
$\UU_n$, for each $n=0,1,\ldots$.  They satisfy the following rules.  The first
two say that the universes form a sequential hierarchy of types, and the third expresses
the idea that an object of a universe can serve as a type and stand to the
right of a colon in judgments.

\begin{itemize}
\item $\UU_m : \UU_n$ for $m < n$
\item if $A:\UU_m$ and $m \le n$, then $A:\UU_n$.
\item if $\Gamma \vdash A : \UU_n$, and $x$ is a new variable, then $\vdash \Gamma, x:A \ctx$
\end{itemize}

In the body of the book, an equality judgment $A \jdeq B : \UU_n$ between types
$A$ and $B$ is usually abbreviated to $A \jdeq B$.  This is an instance of
typical ambiguity, and the choice of $n$ doesn't affect the validity of the judgment.

\subsection{Dependent function types (\texorpdfstring{$\Pi$}{Π}-types)}

We introduce a primitive constant $c_\Pi$.  An expression of the form
$c_\Pi(A,\lam{a} B)$ will be written as $\tprd{a:A}B$.  Judgments concerning
such expressions and expressions of the form $\lam{x} b$ are introduced by the following rules.

\begin{itemize}
\item if $\Gamma \vdash A:\UU_n$ and $\Gamma,a:A \vdash B:\UU_n$, then $\Gamma \vdash \tprd{a:A}B : \UU_n$
\item if $\Gamma, a:A \vdash b:B$ then $\Gamma \vdash (\lam{a} b) : (\tprd{a:A} B)$
\item if $g:\tprd{a:A} B$ and $t:A$ then $g(t):B[t/a]$
\end{itemize}

If $a$ does not occur freely in $B$, we abbreviate $\tprd{a:A} B$ as $A
\rightarrow B$ and derive the following rule.

\begin{itemize}
\item if $g:A \rightarrow B$ and $t:A$ then $g(t):B$
\end{itemize}

\subsection{Natural numbers}

The type of natural numbers is obtained by introducing primitive constants
$\N$, $0$, and $\suc$ with the following rules.
\begin{itemize}
  \item $\N : \UU_0$,
  \item $0:\N$,
  \item $\suc:\N\rightarrow \N$.
\end{itemize}

Furthermore, we can define functions by primitive recursion.  If we have
$C : \N \rightarrow \UU_k $ we can introduce a defined constant $f:\tprd{n:\N}C(n)$ whenever we have
  \begin{align*}
    d & : C(0) \\
    e & : \tprd{x:\N}(C(x)\rightarrow C(\suc (x)))
  \end{align*}
with the defining equations
  \begin{align*}
    f(0) & \defeq d \\
    f(\suc (x)) & \defeq e(x,f(x))
  \end{align*}
 
As usual $C,d,e$ may have been obtained in an implicit context $\Gamma$ in which variables $x_1,\ldots,x_n$ are declared.  Then there will be the extra implicit parameters $x_1,\ldots,x_n$, so that the fully explicit primitive recursion schema is
  \begin{align*}
    f(x_1,\dots,x_n,0) & \defeq d(x_1,\dots,x_n) \\
    f(x_1,\dots,x_n,\suc (x)) & \defeq e(x_1,\dots,x_n,x,f(x_1,\dots,x_n,x))
  \end{align*}

\subsection{The finite types}

We introduce primitive constants $\ttt$, $\bfalse$, $\btrue$, $\emptyt$,
$\unit$, $\bool$ satisfying the following rules.

\begin{itemize}
\item $\emptyt : \UU_0$, $\unit : \UU_0$, $\bool : \UU_0$,
\item $\ttt:\unit$, $\bfalse:\bool$, $\btrue:\bool$.
\end{itemize}

Given $C : \emptyt \rightarrow \UU_n$ we can introduce a defined constant $f:\tprd{x:\emptyt} C(x)$, with no defining equations.

Given $C : \unit \rightarrow \UU_n$ and $c : C(\ttt)$ we can introduce a defined constant $f:\tprd{x:\unit} C(x)$, with defining equation $f(\ttt) \defeq c$.

Given $C : \bool \rightarrow \UU_n$, $c : C(\bfalse)$, and $c' : C(\btrue)$, we can introduce a defined constant $f:\tprd{x:\bool} C(x)$, with defining equations
$f(\bfalse)\defeq c$ and $f(\btrue)\defeq c'$.

\subsection{Dependent pair types (\texorpdfstring{$\Sigma$}{Σ}-types)}

We introduce primitive constants $c_\Sigma$ and $c_{\mathsf{pair}}$.  An
expression of the form $c_\Sigma(A,\lam{a} B)$ will be written as $\sm{a:A}B$,
and an expression of the form $c_{\mathsf{pair}}(a,b)$ will be written as $\tup
a b$.  We write $A\times B$ instead of $\sm{x:A} B$ if $x$ is not free in $B$.

Judgments concerning such expressions are introduced by the following
rules.

\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\sm{a:A}B(a) : \UU_n$
\item if, in addition, $x:A$ and $y:B(x)$, then $\tup x y:\sm{a:A}B(a)$
\end{itemize}

If we have $A$ and $B$ as above, $C : \sm{a:A}B(a) \rightarrow \UU_m$, and
\[
  d:\tprd{x:A}{y:B(x)} C(\tup x y)
\]
we can introduce a defined constant 
\[
  f:\tprd{p:\sm{a:A}B(a)} C(p)
\]
with the defining equation
\[
  f(\tup x y)\defeq d(x,y).
\]

\subsection{Coproduct types}
We introduce primitive constants $c_+$, $c_\inlsym$, and $c_\inrsym$.
We will write $A+B$ instead of $c_+(A,B)$, $\inl(a)$ instead of
$c_\inlsym(a)$, and $\inr(a)$ instead of $c_\inrsym(a)$.

\begin{itemize}
\item if $A,B : \UU_n$ then $A + B : \UU_n$
\item moreover, $\inl: A \rightarrow A+B$ and $\inr: B \rightarrow A+B$
\end{itemize}

If we have $A$ and $B$ as above, $C : A+B \rightarrow \UU_m$, $c:\tprd{a:A} C(\inl(a))$, and $c':\tprd{b:B} C(\inr(b))$,
then we can introduce a defined constant $f:\tprd{x:A+B}C(x)$ with the defining equations
\begin{align*}
  f(\inl(a)) & \defeq c(a) \\
  f(\inr(b)) & \defeq c'(b)
\end{align*}

\subsection{$W$-Types}

For $W$-types we introduce primitive constants $c_\wtypesym$ and $c_\suppsym$.
An expression of the form $c_\wtypesym(A,\lam{a} B)$ will be written as
$\wtype{a:A}B$, and an expression of the form $c_\suppsym(x,u)$ will be written
as $\supp(x,u)$

\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\wtype{a:A}B : \UU_n$
\item if moreover, $a:A$ and $u:B(a)\rightarrow \wtype{a:A}B$ then $\supp(a,u):\wtype{a:A}B$.
\end{itemize}
 
Here also we can define functions by total recursion.  If we have $A$ and $B$
as above and $C : \wtype{a:A}B \rightarrow \UU_m$, then we can introduce a defined constant
$f:\tprd{z:\wtype{a:A}B} C(z)$ whenever we have
\[
  d:\tprd{x:A}{u:B(x) \rightarrow \wtype{a:A}B}((\tprd{y:B(x)}C(u(y))) \rightarrow C(\supp(x,u)))
\]
with the defining equation
\[
  f(\supp(x,u)) \defeq d(x,u,f\circ u)
\]

\subsection{Identity types}

We introduce primitive constants $c_\idsym$ and $c_\reflsym$.  We will write
$\id[A] a b$ for $c_\idsym(A,a,b)$ and $\refl a$ for $c_\reflsym(A,a)$, when
$a:A$ is understood.

\begin{itemize}
\item if $A : \UU_n$, $a:A$, and $b:A$ then $\id[A] a b : \UU_n$
\item if, moreover, $a:A$, then $\refl a :\id[A] a a $.
\end{itemize}

If $\Gamma, y:A, z:\id[A] a y \vdash C : \UU_m$ and $\Gamma \vdash d:C[a,\refl{a}/y,z]$ then we can introduce a defined constant 
\[
  f:\tprd{y:A}{z:\id[A] a y} C
\]
with defining equation
\[
  f(a,\refl{a})\defeq d.
\]

\subsection{Algorithmic and semantic issues}

\message{Thierry and Peter can now start re-writing this section.  The
  following text is old.}

\subsubsection*{Conversion and reduction}

Together with $\beta$-conversion
\[
  (\lam{x} t)(u) \defeq t[u/x]
\]
and thinking of $\defeq$ as a rewriting rule (unfolding definitions),
this forms a rewriting system which has the confluence (or Church-Rosser) property: we can
define $t \conv u$ to mean that $t$ and $u$ can be reduced to the same term by using
$\beta$-reduction and recursion.


\subsubsection*{Some Syntactical Properties of the Type Theory}
 This system has the following syntactical properties.

\begin{thm}\label{red}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

\begin{thm}\label{SN}
 If $A : \UU$ then $A$ is strongly normalizable.
If $t:A$ then $A$ and $t$ are strongly normalizable. % note: ``strongly normalizable'' is undefined
\end{thm}

We say that a term is {\em in normal form} if it cannot be reduced.  A closed
normal type has to be a primitive type, i.e., to be of the form $c(\vec{v})$
for some primitive constant $c$ (where $\vec{v}$ may be omitted if empty, for
instance, as with $\N$).  More generally we have the following explicit
description of terms in normal form.

\begin{lem}\label{normal}
The terms in normal form can be described by the following syntax
\begin{align*}
 v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}) \\
 k &\production x \mid k(v) \mid f(\vec{v})(k)
\end{align*}
where $f(\vec{v})$ represents a partial application of the defined function $f$.
In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
If $A$ is in normal form then the 
judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
$t:A$ is decidable.
\end{thm}


 A corollary is the {\em consistency} property: there is no proof of $\emptyt$ in the empty
context. Indeed if we have $t:\emptyt$ then by Theorems \ref{red} and \ref{SN} the term $t$ will reduce
to a term in normal form $t'$ that satisfies $t':\emptyt$, but this is not possible by a 
purely combinatorial argument using Lemma \ref{normal}. Similarly, we have the following
{\em canonicity} property: if $t:N$ in the empty context, then $t$ has to reduce to a
normal form $\suc^k(0)$ for some numeral $k$. Finally, it means that, if we restrict to terms
in normal form, the typing relation is {\em decidable}, and identifying type-checking with
{\em proof-checking}, we can indeed ``recognize a proof of an assertion when we see one''.

\egroup

\section{The inference rules, more formally}\label{syntax-more-formally}

\bgroup % restrict the following macros to this section

%% Basic syntax of type theory:
% judgements
\newcommand{\Gm}{\Gamma}      % \G is used already in some tex systems and not in others, so we don't try to redefine it
\newcommand{\ctx}{\ensuremath{\mathsf{ctx}}}
\newcommand{\emptyctx}{\cdot}
\newcommand{\wfctx}[1]{\vdash #1\ \ctx}
\newcommand{\oftp}[3]{#1 \vdash #2 : #3}
\newcommand{\jdeqtp}[4]{#1 \vdash #2 \jdeq #3 : #4}
\newcommand{\judg}[2]{#1 \vdash #2}
\newcommand{\tmtp}[2]{#1 \mathord{:} #2}
% rules
\newcommand{\form}{\textsc{form}}
\newcommand{\intro}{\textsc{intro}}
\newcommand{\elim}{\textsc{elim}}
\newcommand{\comp}{\textsc{comp}}
\newcommand{\Weak}{\mathsf{Wkg}}
\newcommand{\Vble}{\mathsf{Vble}}
\newcommand{\Exch}{\mathsf{Exch}}
\newcommand{\Subst}{\mathsf{Subst}}

\let\syn\mathsf

A remark for experts---the following comprises a fairly standard presentation of
intensional Martin-L\"{o}f type theory, with some additional features needed in
homotopy type theory. Compared to a reference presentation of
\cite{hofmann:syntax-and-semantics}, the type theory of this book has a few
non-critical differences:
\begin{itemize}
\item universes \`{a} la Russell, in the sense of
\cite{martin-lof:bibliopolis};
\item judgmental $\eta$ and function extensionality for $\Pi$ types;
\end{itemize}
and a few features essential for homotopy type theory:
\begin{itemize}
\item the univalence axiom;
\item higher inductive types.
\end{itemize}

As a matter of convenience, the book primarily defines functions by induction
using definition by \emph{pattern matching}. It is possible to formalize the
notion of pattern matching, as done in \autoref{syntax-informally}. However, the
standard type-theoretic presentation is to introduce a single \emph{dependent
eliminator} for each type former, from which functions out of that type must be
defined.\footnote{This approach is easier to formalize both syntactically and
semantically, as it amounts to the universal property of the type former.}
The two approaches are equivalent; see \autoref{sec:pattern-matching} for a
longer discussion.

\subsection{Judgments}

Type theory has three basic judgments:
\begin{mathpar}
\wfctx\Gm
\and
\oftp\Gm{a}{A}
\and
\jdeqtp\Gm{a}{a'}{A}
\end{mathpar}

We define these judgments inductively using inference rules. In the notation of
this section, to conclude the judgment below the horizontal line, it is
necessary to prove the judgments above the line. A valid derivation of a
judgment is a tree constructed from these inference rules, whose final
conclusion is the judgment in question, and none of whose component rules has
unresolved hypotheses. (In other words, all the leaves of the tree must be
rules with no hypotheses, such as $\Vble$ and $\UU$-\intro.)


For example, the following is part of a derivation of $\oftp{\emptyctx}{\lam{x:\unit}
x}{\unit\to\unit}$ (a copy of the missing part is visible on the left hand side).
\begin{mathpar}
  \def\deriveemptycontext{\inferrule*[right=\ctx-\textsc{emp}] {\ } {\wfctx {\emptyctx}}}
  \def\deriveunitform{\inferrule*[right=$\unit$-\form] \deriveemptycontext {\oftp{}{\unit}{\UU_0}}}
  \def\derivexisoftypeunit{\inferrule*[right=\ctx-\textsc{ext}] \deriveunitform {\wfctx {\tmtp x\unit}}}
  \inferrule*[right=$\Pi$-\intro]
     {
        \inferrule*[right=$\unit$-\form]
           \derivexisoftypeunit
           {\oftp{\tmtp x\unit}{\unit}{\UU_0}} \\
        \inferrule*[right=$\Vble$]
           \vdots % \derivexisoftypeunit
           {\oftp{\tmtp x\unit}{x}{\unit}}}
     {\oftp{\emptyctx}{\lam{x:\unit} x}{\unit\to\unit}}
\end{mathpar}

\subsection{Contexts}

A context is a list of assumptions of the form $x_i:A_i$. The empty list is a
valid context; given a valid context $\Gm$, and a valid type $A$ in that context,
$\Gm$ can be extended with an assumption of type $A$.

\begin{mathpar}
  \inferrule*[right=\ctx-\textsc{emp}]
  {\ }
  {\wfctx\emptyctx}
\and
  \inferrule*[right=\ctx-\textsc{ext}]
  {\oftp\Gm{A}{\UU_i}}
  {\wfctx{(\Gm,\tmtp xA)}}
\end{mathpar}

\subsection{Structural Rules}

Each assumption in the context can be concluded.

\begin{mathpar}
  \inferrule*[right=$\Vble$]
  {\wfctx {\Gm,\tmtp xA,\Delta} }
  {\oftp{\Gm,\tmtp xA,\Delta}{x}{A}}
\end{mathpar}

The following important principles, called \emph{substitution} and
\emph{weakening}, need not be assumed. It is possible to show, by induction on
the structure of each judgment's derivation, that whenever their hypotheses are
provable, their conclusion is also provable.

\begin{mathpar}
  \inferrule*[right=$\Subst$]
  {\oftp\Gm{a}{A} \\ \judg{\Gm,\tmtp xA,\Delta}{\mathcal{J}}}
  {\judg{\Gm,\Delta[a/x]}{\mathcal{J}[a/x]}}
\and
  \inferrule*[right=$\Weak$]
  {\oftp\Gm{A}{\UU_i} \\ \judg{\Gm,\Delta}{\mathcal{J}}}
  {\judg{\Gm,\tmtp xA,\Delta}{\mathcal{J}}}
\end{mathpar}

In addition to the judgmental equality rules given for each type former, we also
assume that judgmental equality is an equivalence relation respected by typing.
\begin{mathparpagebreakable}
  \inferrule*{\oftp\Gm{a}{A}}{\jdeqtp\Gm{a}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gm{a}{b}{A}}{\jdeqtp\Gm{b}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gm{a}{b}{A} \\ \jdeqtp\Gm{b}{c}{A}}{\jdeqtp\Gm{a}{c}{A}}
\and
  \inferrule*{\oftp\Gm{a}{A} \\ \jdeqtp\Gm{A}{B}{\UU_i}}{\oftp\Gm{a}{B}}
\and
  \inferrule*{\jdeqtp\Gm{a}{b}{A} \\ \jdeqtp\Gm{A}{B}{\UU_i}}{\jdeqtp\Gm{a}{b}{B}}
\end{mathparpagebreakable}

Additionally, in the logical rules below, we assume rules stating that each constructor preserves definitional equality in each of its arguments; for instance, along with the $\Pi$-\intro\ rule, we assume the rule
\[
  \inferrule*[right=$\Pi$-\intro-eq]
  {\jdeqtp\Gm{A}{A'}{\UU_i} \\
   \jdeqtp{\Gm,\tmtp xA}{B}{B'}{\UU_i} \\
   \jdeqtp{\Gm,\tmtp xA}{b}{b'}{B}}
  {\jdeqtp\Gm{\lam{x:A} b}{\lam{x:A'} b'}{\tprd{x:A} B}}
\]
However, we omit these rules for brevity.

\subsection{Type universes}

We have an infinite hierarchy of type universes $\UU_i$ for each natural number
$i$; each universe is contained in the next, and any type in $\UU_i$ is also in
$\UU_{i+1}$.

\begin{mathpar}
\inferrule*[right=\UU-\textsc{intro}]
  {\wfctx \Gm }
  {\oftp\Gm{\UU_i}{\UU_{i+1}}}
\and
\inferrule*[right=\UU-\textsc{cumul}]
  {\oftp\Gm{A}{\UU_i}}
  {\oftp\Gm{A}{\UU_{i+1}}}
\end{mathpar}

The rules of type theory maintain the invariant that if $\oftp\Gm{a}{A}$ or
$\jdeqtp\Gm{a}{b}{A}$, then $\oftp\Gm{A}{\UU_i}$ for some $i$.

\subsection{Dependent function types (\texorpdfstring{$\Pi$}{Π}-types)}

In \autoref{sec:function-types}, we introduced non-dependent functions $A\to B$ in
order to define a family of types as a function $\lam{x:A} B:A\to\UU_i$, which
gives rise to a dependent function $\tprd{x:A} B$. Contexts allow us to speak
directly about the types of terms with free variables, so we can instead express
a family of types simply as a type $B$ with a free variable $x:A$, i.e.,
$\oftp{\tmtp xA}{B}{\UU_i}$. As a consequence, we don't need non-dependent
functions to define dependent functions. In fact, the rules for each type former
will not refer to any other type former.

Each type former from here on has a uniform set of rules:
\begin{itemize}
\item a \emph{formation} rule, stating when the type former can be applied;
\item some \emph{introduction} rules, stating how to inhabit the type;
\item an \emph{elimination} rule, or induction principle, stating how to use an
element of the type;
\item some \emph{computation} rules, corresponding to the introduction rules,
giving a judgmental equality for when the elimination rule is applied to an
introductory form.
\end{itemize}

\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-\form]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i}}
  {\oftp\Gm{\tprd{x:A}B}{\UU_i}}
\and
  \inferrule*[right=$\Pi$-\intro]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i} \\ \oftp{\Gm,\tmtp xA}{b}{B}}
  {\oftp\Gm{\lam{x:A} b}{\tprd{x:A} B}}
\and
  \inferrule*[right=$\Pi$-\elim]
  {\oftp\Gm{f}{\tprd{x:A} B} \\ \oftp\Gm{a}{A}}
  {\oftp\Gm{f(a)}{B[a/x]}}
\and
  \inferrule*[right=$\Pi$-\comp]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i} \\ \oftp{\Gm,\tmtp xA}{b}{B} \\ \oftp\Gm{a}{A}}
  {\jdeqtp\Gm{(\lam{x:A} b)(a)}{b[a/x]}{B[a/x]}}
\end{mathparpagebreakable}

The expression $\lam{x:A} b$ binds free occurrences of $x$ in $b$, as does $\tprd{x:A} B$ for
$B$.

When $B$ does not contain free occurrences of $x$, we obtain the ordinary
function type $A\to B \defeq \tprd{x:A} B$.

\subsection{Dependent pair types (\texorpdfstring{$\Sigma$}{Σ}-types)}

In \autoref{sec:sigma-types}, we needed $\to$ and $\prdsym$ types in order to
define the introduction and elimination rules for $\smsym$; as in the previous
section, we can instead use the context to express dependency without involving
other type formers.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Sigma$-\form]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i}}
  {\oftp\Gm{\tsm{x:A} B}{\UU_i}}
\and
  \inferrule*[right=$\Sigma$-\intro]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i} \\
   \oftp\Gm{a}{A} \\ \oftp\Gm{b}{B[a/x]}}
  {\oftp\Gm{\tup ab}{\tsm{x:A} B}}
\and
  \inferrule*[right=$\Sigma$-\elim]
  {\oftp{\Gm,\tmtp y{\tsm{x:A} B}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp aA,\tmtp b{B[a/x]}}{g}{C[\tup ab/y]} \\
   \oftp\Gm{p}{\tsm{x:A} B}}
  {\oftp\Gm{\ind{\tsm{x:A} B}(y.C,a.b.g,p)}{C[\fst(p),\snd(p)/x,y]}}
\and
  \inferrule*[right=$\Sigma$-\comp]
  {\oftp{\Gm,\tmtp xA}{B}{\UU_i} \\
   \oftp\Gm{a'}{A} \\ \oftp\Gm{b'}{B[a'/x]} \\
   \oftp{\Gm,\tmtp y{\tsm{x:A} B}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp aA,\tmtp b{B[a/x]}}{g}{C[\tup ab/y]}}
  {\jdeqtp\Gm{\ind{\tsm{x:A} B}(y.C,a.b.g,\tup{a'}{b'})}{g[a',b'/a,b]}{C[a',b'/a,b]}}
\end{mathparpagebreakable}

The expression $\tsm{x:A} B$ binds free occurrences of $x$ in $B$. Furthermore, because
$\ind{\tsm{x:A} B}$ has some arguments with free variables beyond those in $\Gm$,
we bind (following the variable names above) $y$ in $C$, and $a$ and $b$ in $g$.
These bindings are written as $y.C$ and $a.b.g$, to indicate the names of the bound
variables, as discussed in \autoref{formal-intro}. In particular, we treat $\ind{\tsm{x:A} B}$ as a primitive,
two of whose arguments contain binders; this is superficially similar to, but
different from, $\ind{\tsm{x:A} B}$ being a function that takes functions as
arguments.

When $B$ does not contain free occurrences of $x$, we obtain the cartesian
product $A \times B := \tsm{x:A} B$.

\subsection{Identity types}

This presentation corresponds to the Martin-L\"{o}f rule in
\autoref{sec:identity-types}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\idsym$-\form]
  {\oftp\Gm{A}{\UU_i} \\ \oftp\Gm{a}{A} \\ \oftp\Gm{b}{A}}
  {\oftp\Gm{\id[A]{a}{b}}{\UU_i}}
\and
  \inferrule*[right=$\idsym$-\intro]
  {\oftp\Gm{A}{\UU_i} \\ \oftp\Gm{a}{A}}
  {\oftp\Gm{\refl a}{\id[A]aa}}
\and
  \inferrule*[right=$\idsym$-\elim]
  {\oftp{\Gm,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gm{a}{A} \\ \oftp\Gm{b}{A} \\ \oftp\Gm{p'}{\id[A]ab}}
  {\oftp\Gm{\ind{\idsym_A}(x.y.p.C,z.c,a,b,p)}{C[a,b,p'/x,y,p]}}
\and
  \inferrule*[right=$\idsym$-\comp]
  {\oftp{\Gm,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gm{a}{A}}
  {\jdeqtp\Gm{\ind{\idsym_A}(x.y.p.C,z.c,a,a,\refl a)}{c[a/z]}{C[a,a,\refl a/x,y,p]}}
\end{mathparpagebreakable}

In $\ind{\idsym_A}$, $x$, $y$, and $p$ are bound in $C$, and $z$ is bound in
$c$.

\subsection{The empty type $\emptyt$}

\begin{mathparpagebreakable}
  \inferrule*[right=$\emptyt$-\form]
  {\wfctx\Gm}
  {\oftp\Gm\emptyt{\UU_i}}
\and
  \inferrule*[right=$\emptyt$-\elim]
  {\oftp{\Gm,\tmtp x\emptyt}{C}{\UU_i} \\ \oftp\Gm{z}{\emptyt}}
  {\oftp\Gm{\ind{\emptyt}(x.C,z)}{C[z/x]}}
\end{mathparpagebreakable}

In $\ind{\emptyt}$, $x$ is bound in $C$.  The empty type comes with no introduction rule and no computation rule.

\subsection{The unit type $\unit$}

\begin{mathparpagebreakable}
  \inferrule*[right=$\unit$-\form]
  {\wfctx\Gm}
  {\oftp\Gm\unit{\UU_i}}
\and
  \inferrule*[right=$\unit$-\intro]
  {\wfctx\Gm}
  {\oftp\Gm{\ttt}{\unit}}
\and
  \inferrule*[right=$\unit$-\elim]
  {\oftp{\Gm,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp y\unit}{c}{C[y/x]} \\
   \oftp\Gm{z}{\unit}}
  {\oftp\Gm{\ind{\unit}(x.C,y.c,z)}{C[y/x]}}
\and
  \inferrule*[right=$\unit$-\comp]
  {\oftp{\Gm,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp y\unit}{c}{C[y/x]}}
  {\jdeqtp\Gm{\ind{\unit}(x.C,y.c,\ttt)}{c[\ttt/y]}{C[\ttt/x]}}
\end{mathparpagebreakable}

In $\ind{\unit}$, $x$ is bound in $C$, and $y$ is bound in $c$.

\subsection{Coproduct types}

\begin{mathparpagebreakable}
  \inferrule*[right=$+$-\form]
  {\oftp\Gm{A}{\UU_i} \\ \oftp\Gm{B}{\UU_i}}
  {\oftp\Gm{A+B}{\UU_i}}
\and
  \inferrule*[right=$+$-\intro${}_1$]
  {\oftp\Gm{A}{\UU_i} \\ \oftp\Gm{B}{\UU_i} \\ \oftp\Gm{a}{A}}
  {\oftp\Gm{\inl(a)}{A+B}}
\and
  \inferrule*[right=$+$-\intro${}_2$]
  {\oftp\Gm{A}{\UU_i} \\ \oftp\Gm{B}{\UU_i} \\ \oftp\Gm{b}{B}}
  {\oftp\Gm{\inr(b)}{A+B}}
\and
  \inferrule*[right=$+$-\elim]
  {\oftp{\Gm,\tmtp x{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp aA}{c}{C[\inl(a)/x]} \\
   \oftp{\Gm,\tmtp bB}{d}{C[\inr(b)/x]} \\
   \oftp\Gm{z}{A+B}}
  {\oftp\Gm{\ind{A+B}(x.C,a.c,b.d,z)}{C[z/x]}}
\and
  \inferrule*[right=$+$-\comp${}_1$]
  {\oftp{\Gm,\tmtp x{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp aA}{c}{C[\inl(a)/x]} \\
   \oftp{\Gm,\tmtp bB}{d}{C[\inr(b)/x]} \\
   \oftp\Gm{a'}{A}}
  {\jdeqtp\Gm{\ind{A+B}(x.C,a.c,b.d,\inl(a'))}{c[a'/a]}{C[\inl(a')/x]}}
\and
  \inferrule*[right=$+$-\comp${}_2$]
  {\oftp{\Gm,\tmtp x{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gm,\tmtp aA}{c}{C[\inl(a)/x]} \\
   \oftp{\Gm,\tmtp bB}{d}{C[\inr(b)/x]} \\
   \oftp\Gm{b'}{B}}
  {\jdeqtp\Gm{\ind{A+B}(x.C,a.c,b.d,\inr(b'))}{d[b'/b]}{C[\inr(b')/x]}}
\end{mathparpagebreakable}

In $\ind{A+B}$, $x$ is bound in $C$, $a$ is bound in $c$, and $b$ is bound in
$d$.

\subsection{The natural number type}

\begin{mathparpagebreakable}
  \inferrule*[right=$\N$-\form]
  {\wfctx\Gm}
  {\oftp\Gm{\N}{\UU_i}}
\and
  \inferrule*[right=$\N$-\intro${}_1$]
  {\wfctx\Gm}
  {\oftp\Gm{0}{\N}}
\and
  \inferrule*[right=$\N$-\intro${}_2$]
  {\oftp\Gm{n}{\N}}
  {\oftp\Gm{\suc(n)}{\N}}
\and
  \inferrule*[right=$\N$-\elim]
  {\oftp{\Gm,\tmtp x{\N}}{C}{\UU_i} \\
   \oftp\Gm{c_0}{C[0/x]} \\
   \oftp{\Gm,\tmtp y\N,\tmtp{z}{C[y/x]}}{c_s}{C[\suc(y)/x]} \\
   \oftp\Gm{n}{\N}}
  {\oftp\Gm{\ind{\N}(x.C,c_0,y.z.c_s,n)}{C[n/x]}}
\and
  \inferrule*[right=$\N$-\comp${}_1$]
  {\oftp{\Gm,\tmtp x{\N}}{C}{\UU_i} \\
   \oftp\Gm{c_0}{C[0/x]} \\
   \oftp{\Gm,\tmtp y\N,\tmtp{z}{C[y/x]}}{c_s}{C[\suc(y)/x]}}
  {\jdeqtp\Gm{\ind{\N}(x.C,c_0,y.z.c_s,0)}{c_0}{C[0/x]}}
\and
{\small
  \inferrule*[right=$\N$-\comp${}_2$]
  {\oftp{\Gm,\tmtp x{\N}}{C}{\UU_i} \\
   \oftp\Gm{c_0}{C[0/x]} \\
   \oftp{\Gm,\tmtp y\N,\tmtp{z}{C[y/x]}}{c_s}{C[\suc(y)/x]} \\
   \oftp\Gm{n}{\N}}
  {\jdeqtp\Gm{\ind{\N}(x.C,c_0,y.z.c_s,\suc(n))}
   {c_s[n,\ind{\N}(x.C,c_0,y.z.c_s,n)/y,z]}{C[\suc(n)/x]}}}
\end{mathparpagebreakable}

In $\ind{\N}$, $x$ is bound in $C$, and $y$ and $z$ are bound in $c_s$.

\subsection{The circle type}

Here we give an example of a higher inductive type. Note that these rules do not
precisely follow the pattern of the ordinary inductive types above: the rules
refer to the notions of transport and functoriality of maps
(\autoref{sec:functors}), and the second computation rule is a propositional,
not judgmental, equality. These differences are discussed in
\autoref{sec:dependent-paths}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Sn^1$-\form]
  {\wfctx\Gm}
  {\oftp\Gm{\Sn^1}{\UU_i}}
\and
  \inferrule*[right=$\Sn^1$-\intro${}_1$]
  {\wfctx\Gm}
  {\oftp\Gm{\base}{\Sn^1}}
\and
  \inferrule*[right=$\Sn^1$-\intro${}_2$]
  {\wfctx\Gm}
  {\oftp\Gm{\lloop}{\id[\Sn^1]{\base}{\base}}}
\and
  \inferrule*[right=$\Sn^1$-\elim]
  {\oftp{\Gm,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gm}{b}{C[\base/x]} \\
   \oftp{\Gm}{\ell}{\id[\Sn^1]{\transfib{C}{\lloop}{b}}{b}} \\
   \oftp\Gm{p}{\Sn^1}}
  {\oftp\Gm{\ind{\Sn^1}(x.C,b,\ell,p)}{C[p/x]}}
\and
  \inferrule*[right=$\Sn^1$-\comp${}_1$]
  {\oftp{\Gm,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gm}{b}{C[\base/x]} \\
   \oftp{\Gm}{\ell}{\id[\Sn^1]{\transfib{C}{\lloop}{b}}{b}}}
  {\jdeqtp\Gm{\ind{\Sn^1}(x.C,b,\ell,\base)}{b}{C[\base/x]}}
\and
  \inferrule*[right=$\Sn^1$-\comp${}_2$]
  {\oftp{\Gm,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gm}{b}{C[\base/x]} \\
   \oftp{\Gm}{\ell}{\id[\Sn^1]{\transfib{C}{\lloop}{b}}{b}}}
  {\oftp\Gm{\Sn^1\text{-}\mathsf{loopcomp}}
    {\apd{(\lam{y:\Sn^1} \ind{\Sn^1}(x.C,b,\ell,y))}{\lloop} = \ell}}
\end{mathparpagebreakable}

In $\ind{\Sn^1}$, $x$ is bound in $C$.

\subsection{Further rules}

We assume stronger rules about $\Pi$ types than fit cleanly into the pattern
above. In the extensionality rule below, $\isequiv$ is any of the equivalent
notions defined in \autoref{cha:equivalences}, and $\happly$ is the function
defined in \autoref{sec:compute-pi}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-$\eta$]
  {\oftp\Gm{f}{\tprd{x:A} B}}
  {\jdeqtp\Gm{f}{(\lam{x:A}f(x))}{\tprd{x:A} B}}
\and
  \inferrule*[right=$\Pi$-\textsc{ext}]
  {\oftp\Gm{f}{\tprd{x:A} B} \\
   \oftp\Gm{g}{\tprd{x:A} B}}
  {\oftp\Gm{\happly\text{-}\isequiv}{\isequiv(\happly_{f,g})}}
\end{mathparpagebreakable}

There are two basic ways of treating the univalence axiom, or any other axiom
which does not introduce new syntax or new judgmental equalities---we could
either add a primitive constant to the theory which inhabits the axiom, or we
could simply prove all theorems in a context hypothesizing a variable which
inhabits the axiom. While these are essentially equivalent, we choose the former
approach because we consider the univalence axiom a core part of homotopy type
theory. 

In the axiom below, $\idtoeqv$ is the function defined in
\autoref{sec:compute-universe}, and $\isequiv$ is again any suitable notion
from \autoref{cha:equivalences}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\UU$-\textsc{univ}]
  {\oftp\Gm{A}{\UU_i} \\
   \oftp\Gm{B}{\UU_i}}
  {\oftp\Gm{\idtoeqv\text{-}\isequiv}{\isequiv(\idtoeqv_{A,B})}}
\end{mathparpagebreakable}

\egroup

\section{Notes}\label{subsec:general-remarks}

  %This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

  The system of rules with introduction (primitive constants) and elimination
  and computation rules (defined constant) is inspired by Gentzen natural
  deduction. The possibility of strengthening the elimination rule for
  existential quantification was indicated in \cite{Howard-1969}. The
  strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
  and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
  $W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
  of trees introduced by \cite{Tait-1968}.
  %inspired from unpublished work of Spector.

  The generalized form of primitive recursion for natural numbers and ordinals
  appear in \cite{Hilbert-1925}.  This motivated G\"odel's system $T$,
  \cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
  following \cite{Goedel-1958}, the terminology ``definitional equality'' for
  conversion: two terms are {\em definitionally equal} if they reduce to a
  common term by means of a sequence of applications of the reduction
  rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
  presentation of {\em Automath}.

  Streicher \cite[Theorem 4.13]{Streicher-1991}, explains how to give the
  semantics in contextual category of terms in normal form using a simple syntax
  similar to the one we have presented.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 

